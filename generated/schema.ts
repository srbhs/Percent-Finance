// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class yVaultPrizePoolBuilderPrizePoolCreatedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVaultPrizePoolBuilderPrizePoolCreatedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVaultPrizePoolBuilderPrizePoolCreatedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVaultPrizePoolBuilderPrizePoolCreatedEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): yVaultPrizePoolBuilderPrizePoolCreatedEvent | null {
    return store.get(
      "yVaultPrizePoolBuilderPrizePoolCreatedEvent",
      id
    ) as yVaultPrizePoolBuilderPrizePoolCreatedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get prizePool(): Bytes {
    let value = this.get("prizePool");
    return value.toBytes();
  }

  set prizePool(value: Bytes) {
    this.set("prizePool", Value.fromBytes(value));
  }
}

export class yVaultPrizePoolBuildercreateSingleRandomWinnerCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVaultPrizePoolBuildercreateSingleRandomWinnerCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVaultPrizePoolBuildercreateSingleRandomWinnerCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVaultPrizePoolBuildercreateSingleRandomWinnerCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVaultPrizePoolBuildercreateSingleRandomWinnerCall | null {
    return store.get(
      "yVaultPrizePoolBuildercreateSingleRandomWinnerCall",
      id
    ) as yVaultPrizePoolBuildercreateSingleRandomWinnerCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get prizePoolConfig_vault(): Bytes {
    let value = this.get("prizePoolConfig_vault");
    return value.toBytes();
  }

  set prizePoolConfig_vault(value: Bytes) {
    this.set("prizePoolConfig_vault", Value.fromBytes(value));
  }

  get prizePoolConfig_reserveRateMantissa(): BigInt {
    let value = this.get("prizePoolConfig_reserveRateMantissa");
    return value.toBigInt();
  }

  set prizePoolConfig_reserveRateMantissa(value: BigInt) {
    this.set("prizePoolConfig_reserveRateMantissa", Value.fromBigInt(value));
  }

  get prizePoolConfig_maxExitFeeMantissa(): BigInt {
    let value = this.get("prizePoolConfig_maxExitFeeMantissa");
    return value.toBigInt();
  }

  set prizePoolConfig_maxExitFeeMantissa(value: BigInt) {
    this.set("prizePoolConfig_maxExitFeeMantissa", Value.fromBigInt(value));
  }

  get prizePoolConfig_maxTimelockDuration(): BigInt {
    let value = this.get("prizePoolConfig_maxTimelockDuration");
    return value.toBigInt();
  }

  set prizePoolConfig_maxTimelockDuration(value: BigInt) {
    this.set("prizePoolConfig_maxTimelockDuration", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_rngService(): Bytes {
    let value = this.get("prizeStrategyConfig_rngService");
    return value.toBytes();
  }

  set prizeStrategyConfig_rngService(value: Bytes) {
    this.set("prizeStrategyConfig_rngService", Value.fromBytes(value));
  }

  get prizeStrategyConfig_prizePeriodStart(): BigInt {
    let value = this.get("prizeStrategyConfig_prizePeriodStart");
    return value.toBigInt();
  }

  set prizeStrategyConfig_prizePeriodStart(value: BigInt) {
    this.set("prizeStrategyConfig_prizePeriodStart", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_prizePeriodSeconds(): BigInt {
    let value = this.get("prizeStrategyConfig_prizePeriodSeconds");
    return value.toBigInt();
  }

  set prizeStrategyConfig_prizePeriodSeconds(value: BigInt) {
    this.set("prizeStrategyConfig_prizePeriodSeconds", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_ticketName(): string {
    let value = this.get("prizeStrategyConfig_ticketName");
    return value.toString();
  }

  set prizeStrategyConfig_ticketName(value: string) {
    this.set("prizeStrategyConfig_ticketName", Value.fromString(value));
  }

  get prizeStrategyConfig_ticketSymbol(): string {
    let value = this.get("prizeStrategyConfig_ticketSymbol");
    return value.toString();
  }

  set prizeStrategyConfig_ticketSymbol(value: string) {
    this.set("prizeStrategyConfig_ticketSymbol", Value.fromString(value));
  }

  get prizeStrategyConfig_sponsorshipName(): string {
    let value = this.get("prizeStrategyConfig_sponsorshipName");
    return value.toString();
  }

  set prizeStrategyConfig_sponsorshipName(value: string) {
    this.set("prizeStrategyConfig_sponsorshipName", Value.fromString(value));
  }

  get prizeStrategyConfig_sponsorshipSymbol(): string {
    let value = this.get("prizeStrategyConfig_sponsorshipSymbol");
    return value.toString();
  }

  set prizeStrategyConfig_sponsorshipSymbol(value: string) {
    this.set("prizeStrategyConfig_sponsorshipSymbol", Value.fromString(value));
  }

  get prizeStrategyConfig_ticketCreditLimitMantissa(): BigInt {
    let value = this.get("prizeStrategyConfig_ticketCreditLimitMantissa");
    return value.toBigInt();
  }

  set prizeStrategyConfig_ticketCreditLimitMantissa(value: BigInt) {
    this.set(
      "prizeStrategyConfig_ticketCreditLimitMantissa",
      Value.fromBigInt(value)
    );
  }

  get prizeStrategyConfig_ticketCreditRateMantissa(): BigInt {
    let value = this.get("prizeStrategyConfig_ticketCreditRateMantissa");
    return value.toBigInt();
  }

  set prizeStrategyConfig_ticketCreditRateMantissa(value: BigInt) {
    this.set(
      "prizeStrategyConfig_ticketCreditRateMantissa",
      Value.fromBigInt(value)
    );
  }

  get prizeStrategyConfig_externalERC20Awards(): Array<Address> {
    let value = this.get("prizeStrategyConfig_externalERC20Awards");
    return value.toAddressArray();
  }

  set prizeStrategyConfig_externalERC20Awards(value: Array<Address>) {
    this.set(
      "prizeStrategyConfig_externalERC20Awards",
      Value.fromAddressArray(value)
    );
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    return value.toI32();
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class yVaultPrizePoolBuildercreateyVaultPrizePoolCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save yVaultPrizePoolBuildercreateyVaultPrizePoolCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save yVaultPrizePoolBuildercreateyVaultPrizePoolCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "yVaultPrizePoolBuildercreateyVaultPrizePoolCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): yVaultPrizePoolBuildercreateyVaultPrizePoolCall | null {
    return store.get(
      "yVaultPrizePoolBuildercreateyVaultPrizePoolCall",
      id
    ) as yVaultPrizePoolBuildercreateyVaultPrizePoolCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get config_vault(): Bytes {
    let value = this.get("config_vault");
    return value.toBytes();
  }

  set config_vault(value: Bytes) {
    this.set("config_vault", Value.fromBytes(value));
  }

  get config_reserveRateMantissa(): BigInt {
    let value = this.get("config_reserveRateMantissa");
    return value.toBigInt();
  }

  set config_reserveRateMantissa(value: BigInt) {
    this.set("config_reserveRateMantissa", Value.fromBigInt(value));
  }

  get config_maxExitFeeMantissa(): BigInt {
    let value = this.get("config_maxExitFeeMantissa");
    return value.toBigInt();
  }

  set config_maxExitFeeMantissa(value: BigInt) {
    this.set("config_maxExitFeeMantissa", Value.fromBigInt(value));
  }

  get config_maxTimelockDuration(): BigInt {
    let value = this.get("config_maxTimelockDuration");
    return value.toBigInt();
  }

  set config_maxTimelockDuration(value: BigInt) {
    this.set("config_maxTimelockDuration", Value.fromBigInt(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class StakePrizePoolBuilderPrizePoolCreatedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save StakePrizePoolBuilderPrizePoolCreatedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save StakePrizePoolBuilderPrizePoolCreatedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "StakePrizePoolBuilderPrizePoolCreatedEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): StakePrizePoolBuilderPrizePoolCreatedEvent | null {
    return store.get(
      "StakePrizePoolBuilderPrizePoolCreatedEvent",
      id
    ) as StakePrizePoolBuilderPrizePoolCreatedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get prizePool(): Bytes {
    let value = this.get("prizePool");
    return value.toBytes();
  }

  set prizePool(value: Bytes) {
    this.set("prizePool", Value.fromBytes(value));
  }
}

export class StakePrizePoolBuildercreateSingleRandomWinnerCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save StakePrizePoolBuildercreateSingleRandomWinnerCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save StakePrizePoolBuildercreateSingleRandomWinnerCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "StakePrizePoolBuildercreateSingleRandomWinnerCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): StakePrizePoolBuildercreateSingleRandomWinnerCall | null {
    return store.get(
      "StakePrizePoolBuildercreateSingleRandomWinnerCall",
      id
    ) as StakePrizePoolBuildercreateSingleRandomWinnerCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get prizePoolConfig_token(): Bytes {
    let value = this.get("prizePoolConfig_token");
    return value.toBytes();
  }

  set prizePoolConfig_token(value: Bytes) {
    this.set("prizePoolConfig_token", Value.fromBytes(value));
  }

  get prizePoolConfig_maxExitFeeMantissa(): BigInt {
    let value = this.get("prizePoolConfig_maxExitFeeMantissa");
    return value.toBigInt();
  }

  set prizePoolConfig_maxExitFeeMantissa(value: BigInt) {
    this.set("prizePoolConfig_maxExitFeeMantissa", Value.fromBigInt(value));
  }

  get prizePoolConfig_maxTimelockDuration(): BigInt {
    let value = this.get("prizePoolConfig_maxTimelockDuration");
    return value.toBigInt();
  }

  set prizePoolConfig_maxTimelockDuration(value: BigInt) {
    this.set("prizePoolConfig_maxTimelockDuration", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_rngService(): Bytes {
    let value = this.get("prizeStrategyConfig_rngService");
    return value.toBytes();
  }

  set prizeStrategyConfig_rngService(value: Bytes) {
    this.set("prizeStrategyConfig_rngService", Value.fromBytes(value));
  }

  get prizeStrategyConfig_prizePeriodStart(): BigInt {
    let value = this.get("prizeStrategyConfig_prizePeriodStart");
    return value.toBigInt();
  }

  set prizeStrategyConfig_prizePeriodStart(value: BigInt) {
    this.set("prizeStrategyConfig_prizePeriodStart", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_prizePeriodSeconds(): BigInt {
    let value = this.get("prizeStrategyConfig_prizePeriodSeconds");
    return value.toBigInt();
  }

  set prizeStrategyConfig_prizePeriodSeconds(value: BigInt) {
    this.set("prizeStrategyConfig_prizePeriodSeconds", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_ticketName(): string {
    let value = this.get("prizeStrategyConfig_ticketName");
    return value.toString();
  }

  set prizeStrategyConfig_ticketName(value: string) {
    this.set("prizeStrategyConfig_ticketName", Value.fromString(value));
  }

  get prizeStrategyConfig_ticketSymbol(): string {
    let value = this.get("prizeStrategyConfig_ticketSymbol");
    return value.toString();
  }

  set prizeStrategyConfig_ticketSymbol(value: string) {
    this.set("prizeStrategyConfig_ticketSymbol", Value.fromString(value));
  }

  get prizeStrategyConfig_sponsorshipName(): string {
    let value = this.get("prizeStrategyConfig_sponsorshipName");
    return value.toString();
  }

  set prizeStrategyConfig_sponsorshipName(value: string) {
    this.set("prizeStrategyConfig_sponsorshipName", Value.fromString(value));
  }

  get prizeStrategyConfig_sponsorshipSymbol(): string {
    let value = this.get("prizeStrategyConfig_sponsorshipSymbol");
    return value.toString();
  }

  set prizeStrategyConfig_sponsorshipSymbol(value: string) {
    this.set("prizeStrategyConfig_sponsorshipSymbol", Value.fromString(value));
  }

  get prizeStrategyConfig_ticketCreditLimitMantissa(): BigInt {
    let value = this.get("prizeStrategyConfig_ticketCreditLimitMantissa");
    return value.toBigInt();
  }

  set prizeStrategyConfig_ticketCreditLimitMantissa(value: BigInt) {
    this.set(
      "prizeStrategyConfig_ticketCreditLimitMantissa",
      Value.fromBigInt(value)
    );
  }

  get prizeStrategyConfig_ticketCreditRateMantissa(): BigInt {
    let value = this.get("prizeStrategyConfig_ticketCreditRateMantissa");
    return value.toBigInt();
  }

  set prizeStrategyConfig_ticketCreditRateMantissa(value: BigInt) {
    this.set(
      "prizeStrategyConfig_ticketCreditRateMantissa",
      Value.fromBigInt(value)
    );
  }

  get prizeStrategyConfig_externalERC20Awards(): Array<Address> {
    let value = this.get("prizeStrategyConfig_externalERC20Awards");
    return value.toAddressArray();
  }

  set prizeStrategyConfig_externalERC20Awards(value: Array<Address>) {
    this.set(
      "prizeStrategyConfig_externalERC20Awards",
      Value.fromAddressArray(value)
    );
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    return value.toI32();
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class StakePrizePoolBuildercreateStakePrizePoolCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save StakePrizePoolBuildercreateStakePrizePoolCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save StakePrizePoolBuildercreateStakePrizePoolCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "StakePrizePoolBuildercreateStakePrizePoolCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): StakePrizePoolBuildercreateStakePrizePoolCall | null {
    return store.get(
      "StakePrizePoolBuildercreateStakePrizePoolCall",
      id
    ) as StakePrizePoolBuildercreateStakePrizePoolCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get config_token(): Bytes {
    let value = this.get("config_token");
    return value.toBytes();
  }

  set config_token(value: Bytes) {
    this.set("config_token", Value.fromBytes(value));
  }

  get config_maxExitFeeMantissa(): BigInt {
    let value = this.get("config_maxExitFeeMantissa");
    return value.toBigInt();
  }

  set config_maxExitFeeMantissa(value: BigInt) {
    this.set("config_maxExitFeeMantissa", Value.fromBigInt(value));
  }

  get config_maxTimelockDuration(): BigInt {
    let value = this.get("config_maxTimelockDuration");
    return value.toBigInt();
  }

  set config_maxTimelockDuration(value: BigInt) {
    this.set("config_maxTimelockDuration", Value.fromBigInt(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class SingleRandomWinnerBuilderSingleRandomWinnerCreatedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save SingleRandomWinnerBuilderSingleRandomWinnerCreatedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save SingleRandomWinnerBuilderSingleRandomWinnerCreatedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "SingleRandomWinnerBuilderSingleRandomWinnerCreatedEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): SingleRandomWinnerBuilderSingleRandomWinnerCreatedEvent | null {
    return store.get(
      "SingleRandomWinnerBuilderSingleRandomWinnerCreatedEvent",
      id
    ) as SingleRandomWinnerBuilderSingleRandomWinnerCreatedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get singleRandomWinner(): Bytes {
    let value = this.get("singleRandomWinner");
    return value.toBytes();
  }

  set singleRandomWinner(value: Bytes) {
    this.set("singleRandomWinner", Value.fromBytes(value));
  }

  get ticket(): Bytes {
    let value = this.get("ticket");
    return value.toBytes();
  }

  set ticket(value: Bytes) {
    this.set("ticket", Value.fromBytes(value));
  }

  get sponsorship(): Bytes {
    let value = this.get("sponsorship");
    return value.toBytes();
  }

  set sponsorship(value: Bytes) {
    this.set("sponsorship", Value.fromBytes(value));
  }
}

export class SingleRandomWinnerBuildercreateSingleRandomWinnerCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save SingleRandomWinnerBuildercreateSingleRandomWinnerCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save SingleRandomWinnerBuildercreateSingleRandomWinnerCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "SingleRandomWinnerBuildercreateSingleRandomWinnerCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): SingleRandomWinnerBuildercreateSingleRandomWinnerCall | null {
    return store.get(
      "SingleRandomWinnerBuildercreateSingleRandomWinnerCall",
      id
    ) as SingleRandomWinnerBuildercreateSingleRandomWinnerCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get prizePool(): Bytes {
    let value = this.get("prizePool");
    return value.toBytes();
  }

  set prizePool(value: Bytes) {
    this.set("prizePool", Value.fromBytes(value));
  }

  get config_rngService(): Bytes {
    let value = this.get("config_rngService");
    return value.toBytes();
  }

  set config_rngService(value: Bytes) {
    this.set("config_rngService", Value.fromBytes(value));
  }

  get config_prizePeriodStart(): BigInt {
    let value = this.get("config_prizePeriodStart");
    return value.toBigInt();
  }

  set config_prizePeriodStart(value: BigInt) {
    this.set("config_prizePeriodStart", Value.fromBigInt(value));
  }

  get config_prizePeriodSeconds(): BigInt {
    let value = this.get("config_prizePeriodSeconds");
    return value.toBigInt();
  }

  set config_prizePeriodSeconds(value: BigInt) {
    this.set("config_prizePeriodSeconds", Value.fromBigInt(value));
  }

  get config_ticketName(): string {
    let value = this.get("config_ticketName");
    return value.toString();
  }

  set config_ticketName(value: string) {
    this.set("config_ticketName", Value.fromString(value));
  }

  get config_ticketSymbol(): string {
    let value = this.get("config_ticketSymbol");
    return value.toString();
  }

  set config_ticketSymbol(value: string) {
    this.set("config_ticketSymbol", Value.fromString(value));
  }

  get config_sponsorshipName(): string {
    let value = this.get("config_sponsorshipName");
    return value.toString();
  }

  set config_sponsorshipName(value: string) {
    this.set("config_sponsorshipName", Value.fromString(value));
  }

  get config_sponsorshipSymbol(): string {
    let value = this.get("config_sponsorshipSymbol");
    return value.toString();
  }

  set config_sponsorshipSymbol(value: string) {
    this.set("config_sponsorshipSymbol", Value.fromString(value));
  }

  get config_ticketCreditLimitMantissa(): BigInt {
    let value = this.get("config_ticketCreditLimitMantissa");
    return value.toBigInt();
  }

  set config_ticketCreditLimitMantissa(value: BigInt) {
    this.set("config_ticketCreditLimitMantissa", Value.fromBigInt(value));
  }

  get config_ticketCreditRateMantissa(): BigInt {
    let value = this.get("config_ticketCreditRateMantissa");
    return value.toBigInt();
  }

  set config_ticketCreditRateMantissa(value: BigInt) {
    this.set("config_ticketCreditRateMantissa", Value.fromBigInt(value));
  }

  get config_externalERC20Awards(): Array<Address> {
    let value = this.get("config_externalERC20Awards");
    return value.toAddressArray();
  }

  set config_externalERC20Awards(value: Array<Address>) {
    this.set("config_externalERC20Awards", Value.fromAddressArray(value));
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    return value.toI32();
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class RegistryOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RegistryOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RegistryOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RegistryOwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): RegistryOwnershipTransferredEvent | null {
    return store.get(
      "RegistryOwnershipTransferredEvent",
      id
    ) as RegistryOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class RegistryRegisteredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RegistryRegisteredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RegistryRegisteredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RegistryRegisteredEvent", id.toString(), this);
  }

  static load(id: string): RegistryRegisteredEvent | null {
    return store.get(
      "RegistryRegisteredEvent",
      id
    ) as RegistryRegisteredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get pointer(): Bytes {
    let value = this.get("pointer");
    return value.toBytes();
  }

  set pointer(value: Bytes) {
    this.set("pointer", Value.fromBytes(value));
  }
}

export class RegistryregisterCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RegistryregisterCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RegistryregisterCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RegistryregisterCall", id.toString(), this);
  }

  static load(id: string): RegistryregisterCall | null {
    return store.get("RegistryregisterCall", id) as RegistryregisterCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class RegistryrenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RegistryrenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RegistryrenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RegistryrenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): RegistryrenounceOwnershipCall | null {
    return store.get(
      "RegistryrenounceOwnershipCall",
      id
    ) as RegistryrenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class RegistrytransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save RegistrytransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RegistrytransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RegistrytransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): RegistrytransferOwnershipCall | null {
    return store.get(
      "RegistrytransferOwnershipCall",
      id
    ) as RegistrytransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ReserveOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ReserveOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ReserveOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ReserveOwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): ReserveOwnershipTransferredEvent | null {
    return store.get(
      "ReserveOwnershipTransferredEvent",
      id
    ) as ReserveOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ReserveReserveRateMantissaSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ReserveReserveRateMantissaSetEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ReserveReserveRateMantissaSetEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ReserveReserveRateMantissaSetEvent", id.toString(), this);
  }

  static load(id: string): ReserveReserveRateMantissaSetEvent | null {
    return store.get(
      "ReserveReserveRateMantissaSetEvent",
      id
    ) as ReserveReserveRateMantissaSetEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get rateMantissa(): BigInt {
    let value = this.get("rateMantissa");
    return value.toBigInt();
  }

  set rateMantissa(value: BigInt) {
    this.set("rateMantissa", Value.fromBigInt(value));
  }
}

export class ReserverenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ReserverenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ReserverenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ReserverenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): ReserverenounceOwnershipCall | null {
    return store.get(
      "ReserverenounceOwnershipCall",
      id
    ) as ReserverenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ReservesetRateMantissaCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ReservesetRateMantissaCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ReservesetRateMantissaCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ReservesetRateMantissaCall", id.toString(), this);
  }

  static load(id: string): ReservesetRateMantissaCall | null {
    return store.get(
      "ReservesetRateMantissaCall",
      id
    ) as ReservesetRateMantissaCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ReservetransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ReservetransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ReservetransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ReservetransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): ReservetransferOwnershipCall | null {
    return store.get(
      "ReservetransferOwnershipCall",
      id
    ) as ReservetransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ReservewithdrawReserveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ReservewithdrawReserveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ReservewithdrawReserveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ReservewithdrawReserveCall", id.toString(), this);
  }

  static load(id: string): ReservewithdrawReserveCall | null {
    return store.get(
      "ReservewithdrawReserveCall",
      id
    ) as ReservewithdrawReserveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get prizePool(): Bytes {
    let value = this.get("prizePool");
    return value.toBytes();
  }

  set prizePool(value: Bytes) {
    this.set("prizePool", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class ControlledTokenBuilderCreatedControlledTokenEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ControlledTokenBuilderCreatedControlledTokenEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ControlledTokenBuilderCreatedControlledTokenEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ControlledTokenBuilderCreatedControlledTokenEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ControlledTokenBuilderCreatedControlledTokenEvent | null {
    return store.get(
      "ControlledTokenBuilderCreatedControlledTokenEvent",
      id
    ) as ControlledTokenBuilderCreatedControlledTokenEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }
}

export class ControlledTokenBuilderCreatedTicketEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ControlledTokenBuilderCreatedTicketEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ControlledTokenBuilderCreatedTicketEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ControlledTokenBuilderCreatedTicketEvent", id.toString(), this);
  }

  static load(id: string): ControlledTokenBuilderCreatedTicketEvent | null {
    return store.get(
      "ControlledTokenBuilderCreatedTicketEvent",
      id
    ) as ControlledTokenBuilderCreatedTicketEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }
}

export class ControlledTokenBuildercreateControlledTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ControlledTokenBuildercreateControlledTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ControlledTokenBuildercreateControlledTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ControlledTokenBuildercreateControlledTokenCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ControlledTokenBuildercreateControlledTokenCall | null {
    return store.get(
      "ControlledTokenBuildercreateControlledTokenCall",
      id
    ) as ControlledTokenBuildercreateControlledTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get config_name(): string {
    let value = this.get("config_name");
    return value.toString();
  }

  set config_name(value: string) {
    this.set("config_name", Value.fromString(value));
  }

  get config_symbol(): string {
    let value = this.get("config_symbol");
    return value.toString();
  }

  set config_symbol(value: string) {
    this.set("config_symbol", Value.fromString(value));
  }

  get config_decimals(): i32 {
    let value = this.get("config_decimals");
    return value.toI32();
  }

  set config_decimals(value: i32) {
    this.set("config_decimals", Value.fromI32(value));
  }

  get config_controller(): Bytes {
    let value = this.get("config_controller");
    return value.toBytes();
  }

  set config_controller(value: Bytes) {
    this.set("config_controller", Value.fromBytes(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class ControlledTokenBuildercreateTicketCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ControlledTokenBuildercreateTicketCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ControlledTokenBuildercreateTicketCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ControlledTokenBuildercreateTicketCall", id.toString(), this);
  }

  static load(id: string): ControlledTokenBuildercreateTicketCall | null {
    return store.get(
      "ControlledTokenBuildercreateTicketCall",
      id
    ) as ControlledTokenBuildercreateTicketCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get config_name(): string {
    let value = this.get("config_name");
    return value.toString();
  }

  set config_name(value: string) {
    this.set("config_name", Value.fromString(value));
  }

  get config_symbol(): string {
    let value = this.get("config_symbol");
    return value.toString();
  }

  set config_symbol(value: string) {
    this.set("config_symbol", Value.fromString(value));
  }

  get config_decimals(): i32 {
    let value = this.get("config_decimals");
    return value.toI32();
  }

  set config_decimals(value: i32) {
    this.set("config_decimals", Value.fromI32(value));
  }

  get config_controller(): Bytes {
    let value = this.get("config_controller");
    return value.toBytes();
  }

  set config_controller(value: Bytes) {
    this.set("config_controller", Value.fromBytes(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class ComptrollerBalanceDripActivatedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerBalanceDripActivatedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerBalanceDripActivatedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerBalanceDripActivatedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerBalanceDripActivatedEvent | null {
    return store.get(
      "ComptrollerBalanceDripActivatedEvent",
      id
    ) as ComptrollerBalanceDripActivatedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get dripRatePerSecond(): BigInt {
    let value = this.get("dripRatePerSecond");
    return value.toBigInt();
  }

  set dripRatePerSecond(value: BigInt) {
    this.set("dripRatePerSecond", Value.fromBigInt(value));
  }
}

export class ComptrollerBalanceDripDeactivatedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerBalanceDripDeactivatedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerBalanceDripDeactivatedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerBalanceDripDeactivatedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerBalanceDripDeactivatedEvent | null {
    return store.get(
      "ComptrollerBalanceDripDeactivatedEvent",
      id
    ) as ComptrollerBalanceDripDeactivatedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }
}

export class ComptrollerBalanceDripDrippedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerBalanceDripDrippedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerBalanceDripDrippedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerBalanceDripDrippedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerBalanceDripDrippedEvent | null {
    return store.get(
      "ComptrollerBalanceDripDrippedEvent",
      id
    ) as ComptrollerBalanceDripDrippedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class ComptrollerBalanceDripRateSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerBalanceDripRateSetEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerBalanceDripRateSetEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerBalanceDripRateSetEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerBalanceDripRateSetEvent | null {
    return store.get(
      "ComptrollerBalanceDripRateSetEvent",
      id
    ) as ComptrollerBalanceDripRateSetEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get dripRatePerSecond(): BigInt {
    let value = this.get("dripRatePerSecond");
    return value.toBigInt();
  }

  set dripRatePerSecond(value: BigInt) {
    this.set("dripRatePerSecond", Value.fromBigInt(value));
  }
}

export class ComptrollerDripTokenClaimedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerDripTokenClaimedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerDripTokenClaimedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerDripTokenClaimedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerDripTokenClaimedEvent | null {
    return store.get(
      "ComptrollerDripTokenClaimedEvent",
      id
    ) as ComptrollerDripTokenClaimedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class ComptrollerDripTokenDrippedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerDripTokenDrippedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerDripTokenDrippedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerDripTokenDrippedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerDripTokenDrippedEvent | null {
    return store.get(
      "ComptrollerDripTokenDrippedEvent",
      id
    ) as ComptrollerDripTokenDrippedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class ComptrollerOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerOwnershipTransferredEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerOwnershipTransferredEvent | null {
    return store.get(
      "ComptrollerOwnershipTransferredEvent",
      id
    ) as ComptrollerOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ComptrollerTransferredOutEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerTransferredOutEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerTransferredOutEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerTransferredOutEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerTransferredOutEvent | null {
    return store.get(
      "ComptrollerTransferredOutEvent",
      id
    ) as ComptrollerTransferredOutEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class ComptrollerVolumeDripActivatedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerVolumeDripActivatedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerVolumeDripActivatedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerVolumeDripActivatedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerVolumeDripActivatedEvent | null {
    return store.get(
      "ComptrollerVolumeDripActivatedEvent",
      id
    ) as ComptrollerVolumeDripActivatedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }

  get periodSeconds(): BigInt {
    let value = this.get("periodSeconds");
    return value.toBigInt();
  }

  set periodSeconds(value: BigInt) {
    this.set("periodSeconds", Value.fromBigInt(value));
  }

  get dripAmount(): BigInt {
    let value = this.get("dripAmount");
    return value.toBigInt();
  }

  set dripAmount(value: BigInt) {
    this.set("dripAmount", Value.fromBigInt(value));
  }
}

export class ComptrollerVolumeDripDeactivatedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerVolumeDripDeactivatedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerVolumeDripDeactivatedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerVolumeDripDeactivatedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerVolumeDripDeactivatedEvent | null {
    return store.get(
      "ComptrollerVolumeDripDeactivatedEvent",
      id
    ) as ComptrollerVolumeDripDeactivatedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }
}

export class ComptrollerVolumeDripDrippedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerVolumeDripDrippedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerVolumeDripDrippedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerVolumeDripDrippedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerVolumeDripDrippedEvent | null {
    return store.get(
      "ComptrollerVolumeDripDrippedEvent",
      id
    ) as ComptrollerVolumeDripDrippedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class ComptrollerVolumeDripPeriodEndedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerVolumeDripPeriodEndedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerVolumeDripPeriodEndedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerVolumeDripPeriodEndedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerVolumeDripPeriodEndedEvent | null {
    return store.get(
      "ComptrollerVolumeDripPeriodEndedEvent",
      id
    ) as ComptrollerVolumeDripPeriodEndedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }

  get period(): BigInt {
    let value = this.get("period");
    return value.toBigInt();
  }

  set period(value: BigInt) {
    this.set("period", Value.fromBigInt(value));
  }

  get totalSupply(): BigInt {
    let value = this.get("totalSupply");
    return value.toBigInt();
  }

  set totalSupply(value: BigInt) {
    this.set("totalSupply", Value.fromBigInt(value));
  }

  get drippedTokens(): BigInt {
    let value = this.get("drippedTokens");
    return value.toBigInt();
  }

  set drippedTokens(value: BigInt) {
    this.set("drippedTokens", Value.fromBigInt(value));
  }
}

export class ComptrollerVolumeDripPeriodStartedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerVolumeDripPeriodStartedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerVolumeDripPeriodStartedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerVolumeDripPeriodStartedEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerVolumeDripPeriodStartedEvent | null {
    return store.get(
      "ComptrollerVolumeDripPeriodStartedEvent",
      id
    ) as ComptrollerVolumeDripPeriodStartedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }

  get period(): BigInt {
    let value = this.get("period");
    return value.toBigInt();
  }

  set period(value: BigInt) {
    this.set("period", Value.fromBigInt(value));
  }

  get dripAmount(): BigInt {
    let value = this.get("dripAmount");
    return value.toBigInt();
  }

  set dripAmount(value: BigInt) {
    this.set("dripAmount", Value.fromBigInt(value));
  }

  get endTime(): BigInt {
    let value = this.get("endTime");
    return value.toBigInt();
  }

  set endTime(value: BigInt) {
    this.set("endTime", Value.fromBigInt(value));
  }
}

export class ComptrollerVolumeDripSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerVolumeDripSetEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerVolumeDripSetEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerVolumeDripSetEvent", id.toString(), this);
  }

  static load(id: string): ComptrollerVolumeDripSetEvent | null {
    return store.get(
      "ComptrollerVolumeDripSetEvent",
      id
    ) as ComptrollerVolumeDripSetEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }

  get periodSeconds(): BigInt {
    let value = this.get("periodSeconds");
    return value.toBigInt();
  }

  set periodSeconds(value: BigInt) {
    this.set("periodSeconds", Value.fromBigInt(value));
  }

  get dripAmount(): BigInt {
    let value = this.get("dripAmount");
    return value.toBigInt();
  }

  set dripAmount(value: BigInt) {
    this.set("dripAmount", Value.fromBigInt(value));
  }
}

export class ComptrolleractivateBalanceDripCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrolleractivateBalanceDripCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrolleractivateBalanceDripCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrolleractivateBalanceDripCall", id.toString(), this);
  }

  static load(id: string): ComptrolleractivateBalanceDripCall | null {
    return store.get(
      "ComptrolleractivateBalanceDripCall",
      id
    ) as ComptrolleractivateBalanceDripCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get dripRatePerSecond(): BigInt {
    let value = this.get("dripRatePerSecond");
    return value.toBigInt();
  }

  set dripRatePerSecond(value: BigInt) {
    this.set("dripRatePerSecond", Value.fromBigInt(value));
  }
}

export class ComptrolleractivateVolumeDripCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrolleractivateVolumeDripCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrolleractivateVolumeDripCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrolleractivateVolumeDripCall", id.toString(), this);
  }

  static load(id: string): ComptrolleractivateVolumeDripCall | null {
    return store.get(
      "ComptrolleractivateVolumeDripCall",
      id
    ) as ComptrolleractivateVolumeDripCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }

  get periodSeconds(): BigInt {
    let value = this.get("periodSeconds");
    return value.toBigInt();
  }

  set periodSeconds(value: BigInt) {
    this.set("periodSeconds", Value.fromBigInt(value));
  }

  get dripAmount(): BigInt {
    let value = this.get("dripAmount");
    return value.toBigInt();
  }

  set dripAmount(value: BigInt) {
    this.set("dripAmount", Value.fromBigInt(value));
  }

  get endTime(): BigInt {
    let value = this.get("endTime");
    return value.toBigInt();
  }

  set endTime(value: BigInt) {
    this.set("endTime", Value.fromBigInt(value));
  }
}

export class ComptrollerbeforeTokenMintCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerbeforeTokenMintCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerbeforeTokenMintCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerbeforeTokenMintCall", id.toString(), this);
  }

  static load(id: string): ComptrollerbeforeTokenMintCall | null {
    return store.get(
      "ComptrollerbeforeTokenMintCall",
      id
    ) as ComptrollerbeforeTokenMintCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get referrer(): Bytes {
    let value = this.get("referrer");
    return value.toBytes();
  }

  set referrer(value: Bytes) {
    this.set("referrer", Value.fromBytes(value));
  }
}

export class ComptrollerbeforeTokenTransferCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerbeforeTokenTransferCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerbeforeTokenTransferCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerbeforeTokenTransferCall", id.toString(), this);
  }

  static load(id: string): ComptrollerbeforeTokenTransferCall | null {
    return store.get(
      "ComptrollerbeforeTokenTransferCall",
      id
    ) as ComptrollerbeforeTokenTransferCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value2(): BigInt {
    let value = this.get("value2");
    return value.toBigInt();
  }

  set value2(value: BigInt) {
    this.set("value2", Value.fromBigInt(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }
}

export class ComptrollercaptureClaimsForBalanceDripsForPairsCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollercaptureClaimsForBalanceDripsForPairsCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollercaptureClaimsForBalanceDripsForPairsCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ComptrollercaptureClaimsForBalanceDripsForPairsCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ComptrollercaptureClaimsForBalanceDripsForPairsCall | null {
    return store.get(
      "ComptrollercaptureClaimsForBalanceDripsForPairsCall",
      id
    ) as ComptrollercaptureClaimsForBalanceDripsForPairsCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get dripTokens(): Array<Address> {
    let value = this.get("dripTokens");
    return value.toAddressArray();
  }

  set dripTokens(value: Array<Address>) {
    this.set("dripTokens", Value.fromAddressArray(value));
  }
}

export class ComptrollerclaimDripCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerclaimDripCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerclaimDripCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerclaimDripCall", id.toString(), this);
  }

  static load(id: string): ComptrollerclaimDripCall | null {
    return store.get(
      "ComptrollerclaimDripCall",
      id
    ) as ComptrollerclaimDripCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class ComptrollerclaimDripsCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerclaimDripsCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerclaimDripsCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerclaimDripsCall", id.toString(), this);
  }

  static load(id: string): ComptrollerclaimDripsCall | null {
    return store.get(
      "ComptrollerclaimDripsCall",
      id
    ) as ComptrollerclaimDripsCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get dripTokens(): Array<Address> {
    let value = this.get("dripTokens");
    return value.toAddressArray();
  }

  set dripTokens(value: Array<Address>) {
    this.set("dripTokens", Value.fromAddressArray(value));
  }
}

export class ComptrollerdeactivateBalanceDripCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerdeactivateBalanceDripCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerdeactivateBalanceDripCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerdeactivateBalanceDripCall", id.toString(), this);
  }

  static load(id: string): ComptrollerdeactivateBalanceDripCall | null {
    return store.get(
      "ComptrollerdeactivateBalanceDripCall",
      id
    ) as ComptrollerdeactivateBalanceDripCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get prevDripToken(): Bytes {
    let value = this.get("prevDripToken");
    return value.toBytes();
  }

  set prevDripToken(value: Bytes) {
    this.set("prevDripToken", Value.fromBytes(value));
  }
}

export class ComptrollerdeactivateVolumeDripCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerdeactivateVolumeDripCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerdeactivateVolumeDripCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerdeactivateVolumeDripCall", id.toString(), this);
  }

  static load(id: string): ComptrollerdeactivateVolumeDripCall | null {
    return store.get(
      "ComptrollerdeactivateVolumeDripCall",
      id
    ) as ComptrollerdeactivateVolumeDripCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }

  get prevDripToken(): Bytes {
    let value = this.get("prevDripToken");
    return value.toBytes();
  }

  set prevDripToken(value: Bytes) {
    this.set("prevDripToken", Value.fromBytes(value));
  }
}

export class ComptrollermintAndCaptureVolumeDripsForPairsCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollermintAndCaptureVolumeDripsForPairsCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollermintAndCaptureVolumeDripsForPairsCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ComptrollermintAndCaptureVolumeDripsForPairsCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ComptrollermintAndCaptureVolumeDripsForPairsCall | null {
    return store.get(
      "ComptrollermintAndCaptureVolumeDripsForPairsCall",
      id
    ) as ComptrollermintAndCaptureVolumeDripsForPairsCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get dripTokens(): Array<Address> {
    let value = this.get("dripTokens");
    return value.toAddressArray();
  }

  set dripTokens(value: Array<Address>) {
    this.set("dripTokens", Value.fromAddressArray(value));
  }
}

export class ComptrollerrenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerrenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerrenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerrenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): ComptrollerrenounceOwnershipCall | null {
    return store.get(
      "ComptrollerrenounceOwnershipCall",
      id
    ) as ComptrollerrenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ComptrollersetBalanceDripRateCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollersetBalanceDripRateCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollersetBalanceDripRateCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollersetBalanceDripRateCall", id.toString(), this);
  }

  static load(id: string): ComptrollersetBalanceDripRateCall | null {
    return store.get(
      "ComptrollersetBalanceDripRateCall",
      id
    ) as ComptrollersetBalanceDripRateCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get dripRatePerSecond(): BigInt {
    let value = this.get("dripRatePerSecond");
    return value.toBigInt();
  }

  set dripRatePerSecond(value: BigInt) {
    this.set("dripRatePerSecond", Value.fromBigInt(value));
  }
}

export class ComptrollersetVolumeDripCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollersetVolumeDripCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollersetVolumeDripCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollersetVolumeDripCall", id.toString(), this);
  }

  static load(id: string): ComptrollersetVolumeDripCall | null {
    return store.get(
      "ComptrollersetVolumeDripCall",
      id
    ) as ComptrollersetVolumeDripCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get source(): Bytes {
    let value = this.get("source");
    return value.toBytes();
  }

  set source(value: Bytes) {
    this.set("source", Value.fromBytes(value));
  }

  get measure(): Bytes {
    let value = this.get("measure");
    return value.toBytes();
  }

  set measure(value: Bytes) {
    this.set("measure", Value.fromBytes(value));
  }

  get dripToken(): Bytes {
    let value = this.get("dripToken");
    return value.toBytes();
  }

  set dripToken(value: Bytes) {
    this.set("dripToken", Value.fromBytes(value));
  }

  get isReferral(): boolean {
    let value = this.get("isReferral");
    return value.toBoolean();
  }

  set isReferral(value: boolean) {
    this.set("isReferral", Value.fromBoolean(value));
  }

  get periodSeconds(): BigInt {
    let value = this.get("periodSeconds");
    return value.toBigInt();
  }

  set periodSeconds(value: BigInt) {
    this.set("periodSeconds", Value.fromBigInt(value));
  }

  get dripAmount(): BigInt {
    let value = this.get("dripAmount");
    return value.toBigInt();
  }

  set dripAmount(value: BigInt) {
    this.set("dripAmount", Value.fromBigInt(value));
  }
}

export class ComptrollertransferOutCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollertransferOutCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollertransferOutCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollertransferOutCall", id.toString(), this);
  }

  static load(id: string): ComptrollertransferOutCall | null {
    return store.get(
      "ComptrollertransferOutCall",
      id
    ) as ComptrollertransferOutCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class ComptrollertransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollertransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollertransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollertransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): ComptrollertransferOwnershipCall | null {
    return store.get(
      "ComptrollertransferOwnershipCall",
      id
    ) as ComptrollertransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ComptrollerupdateActiveBalanceDripsForPairsCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerupdateActiveBalanceDripsForPairsCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerupdateActiveBalanceDripsForPairsCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ComptrollerupdateActiveBalanceDripsForPairsCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ComptrollerupdateActiveBalanceDripsForPairsCall | null {
    return store.get(
      "ComptrollerupdateActiveBalanceDripsForPairsCall",
      id
    ) as ComptrollerupdateActiveBalanceDripsForPairsCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ComptrollerupdateActiveVolumeDripsForPairsCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerupdateActiveVolumeDripsForPairsCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerupdateActiveVolumeDripsForPairsCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "ComptrollerupdateActiveVolumeDripsForPairsCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): ComptrollerupdateActiveVolumeDripsForPairsCall | null {
    return store.get(
      "ComptrollerupdateActiveVolumeDripsForPairsCall",
      id
    ) as ComptrollerupdateActiveVolumeDripsForPairsCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class ComptrollerupdateAndClaimDripsCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerupdateAndClaimDripsCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerupdateAndClaimDripsCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerupdateAndClaimDripsCall", id.toString(), this);
  }

  static load(id: string): ComptrollerupdateAndClaimDripsCall | null {
    return store.get(
      "ComptrollerupdateAndClaimDripsCall",
      id
    ) as ComptrollerupdateAndClaimDripsCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get dripTokens(): Array<Address> {
    let value = this.get("dripTokens");
    return value.toAddressArray();
  }

  set dripTokens(value: Array<Address>) {
    this.set("dripTokens", Value.fromAddressArray(value));
  }
}

export class ComptrollerupdateDripsCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ComptrollerupdateDripsCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ComptrollerupdateDripsCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ComptrollerupdateDripsCall", id.toString(), this);
  }

  static load(id: string): ComptrollerupdateDripsCall | null {
    return store.get(
      "ComptrollerupdateDripsCall",
      id
    ) as ComptrollerupdateDripsCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get dripTokens(): Array<Address> {
    let value = this.get("dripTokens");
    return value.toAddressArray();
  }

  set dripTokens(value: Array<Address>) {
    this.set("dripTokens", Value.fromAddressArray(value));
  }
}

export class CompoundPrizePoolBuilderPrizePoolCreatedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolBuilderPrizePoolCreatedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolBuilderPrizePoolCreatedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolBuilderPrizePoolCreatedEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): CompoundPrizePoolBuilderPrizePoolCreatedEvent | null {
    return store.get(
      "CompoundPrizePoolBuilderPrizePoolCreatedEvent",
      id
    ) as CompoundPrizePoolBuilderPrizePoolCreatedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get creator(): Bytes {
    let value = this.get("creator");
    return value.toBytes();
  }

  set creator(value: Bytes) {
    this.set("creator", Value.fromBytes(value));
  }

  get prizePool(): Bytes {
    let value = this.get("prizePool");
    return value.toBytes();
  }

  set prizePool(value: Bytes) {
    this.set("prizePool", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolBuildercreateCompoundPrizePoolCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolBuildercreateCompoundPrizePoolCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolBuildercreateCompoundPrizePoolCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolBuildercreateCompoundPrizePoolCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): CompoundPrizePoolBuildercreateCompoundPrizePoolCall | null {
    return store.get(
      "CompoundPrizePoolBuildercreateCompoundPrizePoolCall",
      id
    ) as CompoundPrizePoolBuildercreateCompoundPrizePoolCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get config_cToken(): Bytes {
    let value = this.get("config_cToken");
    return value.toBytes();
  }

  set config_cToken(value: Bytes) {
    this.set("config_cToken", Value.fromBytes(value));
  }

  get config_maxExitFeeMantissa(): BigInt {
    let value = this.get("config_maxExitFeeMantissa");
    return value.toBigInt();
  }

  set config_maxExitFeeMantissa(value: BigInt) {
    this.set("config_maxExitFeeMantissa", Value.fromBigInt(value));
  }

  get config_maxTimelockDuration(): BigInt {
    let value = this.get("config_maxTimelockDuration");
    return value.toBigInt();
  }

  set config_maxTimelockDuration(value: BigInt) {
    this.set("config_maxTimelockDuration", Value.fromBigInt(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolBuildercreateSingleRandomWinnerCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolBuildercreateSingleRandomWinnerCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolBuildercreateSingleRandomWinnerCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolBuildercreateSingleRandomWinnerCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): CompoundPrizePoolBuildercreateSingleRandomWinnerCall | null {
    return store.get(
      "CompoundPrizePoolBuildercreateSingleRandomWinnerCall",
      id
    ) as CompoundPrizePoolBuildercreateSingleRandomWinnerCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get prizePoolConfig_cToken(): Bytes {
    let value = this.get("prizePoolConfig_cToken");
    return value.toBytes();
  }

  set prizePoolConfig_cToken(value: Bytes) {
    this.set("prizePoolConfig_cToken", Value.fromBytes(value));
  }

  get prizePoolConfig_maxExitFeeMantissa(): BigInt {
    let value = this.get("prizePoolConfig_maxExitFeeMantissa");
    return value.toBigInt();
  }

  set prizePoolConfig_maxExitFeeMantissa(value: BigInt) {
    this.set("prizePoolConfig_maxExitFeeMantissa", Value.fromBigInt(value));
  }

  get prizePoolConfig_maxTimelockDuration(): BigInt {
    let value = this.get("prizePoolConfig_maxTimelockDuration");
    return value.toBigInt();
  }

  set prizePoolConfig_maxTimelockDuration(value: BigInt) {
    this.set("prizePoolConfig_maxTimelockDuration", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_rngService(): Bytes {
    let value = this.get("prizeStrategyConfig_rngService");
    return value.toBytes();
  }

  set prizeStrategyConfig_rngService(value: Bytes) {
    this.set("prizeStrategyConfig_rngService", Value.fromBytes(value));
  }

  get prizeStrategyConfig_prizePeriodStart(): BigInt {
    let value = this.get("prizeStrategyConfig_prizePeriodStart");
    return value.toBigInt();
  }

  set prizeStrategyConfig_prizePeriodStart(value: BigInt) {
    this.set("prizeStrategyConfig_prizePeriodStart", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_prizePeriodSeconds(): BigInt {
    let value = this.get("prizeStrategyConfig_prizePeriodSeconds");
    return value.toBigInt();
  }

  set prizeStrategyConfig_prizePeriodSeconds(value: BigInt) {
    this.set("prizeStrategyConfig_prizePeriodSeconds", Value.fromBigInt(value));
  }

  get prizeStrategyConfig_ticketName(): string {
    let value = this.get("prizeStrategyConfig_ticketName");
    return value.toString();
  }

  set prizeStrategyConfig_ticketName(value: string) {
    this.set("prizeStrategyConfig_ticketName", Value.fromString(value));
  }

  get prizeStrategyConfig_ticketSymbol(): string {
    let value = this.get("prizeStrategyConfig_ticketSymbol");
    return value.toString();
  }

  set prizeStrategyConfig_ticketSymbol(value: string) {
    this.set("prizeStrategyConfig_ticketSymbol", Value.fromString(value));
  }

  get prizeStrategyConfig_sponsorshipName(): string {
    let value = this.get("prizeStrategyConfig_sponsorshipName");
    return value.toString();
  }

  set prizeStrategyConfig_sponsorshipName(value: string) {
    this.set("prizeStrategyConfig_sponsorshipName", Value.fromString(value));
  }

  get prizeStrategyConfig_sponsorshipSymbol(): string {
    let value = this.get("prizeStrategyConfig_sponsorshipSymbol");
    return value.toString();
  }

  set prizeStrategyConfig_sponsorshipSymbol(value: string) {
    this.set("prizeStrategyConfig_sponsorshipSymbol", Value.fromString(value));
  }

  get prizeStrategyConfig_ticketCreditLimitMantissa(): BigInt {
    let value = this.get("prizeStrategyConfig_ticketCreditLimitMantissa");
    return value.toBigInt();
  }

  set prizeStrategyConfig_ticketCreditLimitMantissa(value: BigInt) {
    this.set(
      "prizeStrategyConfig_ticketCreditLimitMantissa",
      Value.fromBigInt(value)
    );
  }

  get prizeStrategyConfig_ticketCreditRateMantissa(): BigInt {
    let value = this.get("prizeStrategyConfig_ticketCreditRateMantissa");
    return value.toBigInt();
  }

  set prizeStrategyConfig_ticketCreditRateMantissa(value: BigInt) {
    this.set(
      "prizeStrategyConfig_ticketCreditRateMantissa",
      Value.fromBigInt(value)
    );
  }

  get prizeStrategyConfig_externalERC20Awards(): Array<Address> {
    let value = this.get("prizeStrategyConfig_externalERC20Awards");
    return value.toAddressArray();
  }

  set prizeStrategyConfig_externalERC20Awards(value: Array<Address>) {
    this.set(
      "prizeStrategyConfig_externalERC20Awards",
      Value.fromAddressArray(value)
    );
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    return value.toI32();
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get value0(): Bytes {
    let value = this.get("value0");
    return value.toBytes();
  }

  set value0(value: Bytes) {
    this.set("value0", Value.fromBytes(value));
  }
}

export class PermitAndDepositDaiOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save PermitAndDepositDaiOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save PermitAndDepositDaiOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "PermitAndDepositDaiOwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): PermitAndDepositDaiOwnershipTransferredEvent | null {
    return store.get(
      "PermitAndDepositDaiOwnershipTransferredEvent",
      id
    ) as PermitAndDepositDaiOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class PermitAndDepositDaidepositToCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save PermitAndDepositDaidepositToCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save PermitAndDepositDaidepositToCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("PermitAndDepositDaidepositToCall", id.toString(), this);
  }

  static load(id: string): PermitAndDepositDaidepositToCall | null {
    return store.get(
      "PermitAndDepositDaidepositToCall",
      id
    ) as PermitAndDepositDaidepositToCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get dai(): Bytes {
    let value = this.get("dai");
    return value.toBytes();
  }

  set dai(value: Bytes) {
    this.set("dai", Value.fromBytes(value));
  }

  get prizePool(): Bytes {
    let value = this.get("prizePool");
    return value.toBytes();
  }

  set prizePool(value: Bytes) {
    this.set("prizePool", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }

  get referrer(): Bytes {
    let value = this.get("referrer");
    return value.toBytes();
  }

  set referrer(value: Bytes) {
    this.set("referrer", Value.fromBytes(value));
  }
}

export class PermitAndDepositDaipermitAndDepositToCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save PermitAndDepositDaipermitAndDepositToCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save PermitAndDepositDaipermitAndDepositToCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("PermitAndDepositDaipermitAndDepositToCall", id.toString(), this);
  }

  static load(id: string): PermitAndDepositDaipermitAndDepositToCall | null {
    return store.get(
      "PermitAndDepositDaipermitAndDepositToCall",
      id
    ) as PermitAndDepositDaipermitAndDepositToCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get dai(): Bytes {
    let value = this.get("dai");
    return value.toBytes();
  }

  set dai(value: Bytes) {
    this.set("dai", Value.fromBytes(value));
  }

  get holder(): Bytes {
    let value = this.get("holder");
    return value.toBytes();
  }

  set holder(value: Bytes) {
    this.set("holder", Value.fromBytes(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get expiry(): BigInt {
    let value = this.get("expiry");
    return value.toBigInt();
  }

  set expiry(value: BigInt) {
    this.set("expiry", Value.fromBigInt(value));
  }

  get allowed(): boolean {
    let value = this.get("allowed");
    return value.toBoolean();
  }

  set allowed(value: boolean) {
    this.set("allowed", Value.fromBoolean(value));
  }

  get v(): i32 {
    let value = this.get("v");
    return value.toI32();
  }

  set v(value: i32) {
    this.set("v", Value.fromI32(value));
  }

  get r(): Bytes {
    let value = this.get("r");
    return value.toBytes();
  }

  set r(value: Bytes) {
    this.set("r", Value.fromBytes(value));
  }

  get s(): Bytes {
    let value = this.get("s");
    return value.toBytes();
  }

  set s(value: Bytes) {
    this.set("s", Value.fromBytes(value));
  }

  get prizePool(): Bytes {
    let value = this.get("prizePool");
    return value.toBytes();
  }

  set prizePool(value: Bytes) {
    this.set("prizePool", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }

  get referrer(): Bytes {
    let value = this.get("referrer");
    return value.toBytes();
  }

  set referrer(value: Bytes) {
    this.set("referrer", Value.fromBytes(value));
  }
}

export class PermitAndDepositDairenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save PermitAndDepositDairenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save PermitAndDepositDairenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("PermitAndDepositDairenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): PermitAndDepositDairenounceOwnershipCall | null {
    return store.get(
      "PermitAndDepositDairenounceOwnershipCall",
      id
    ) as PermitAndDepositDairenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class PermitAndDepositDaitransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save PermitAndDepositDaitransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save PermitAndDepositDaitransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("PermitAndDepositDaitransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): PermitAndDepositDaitransferOwnershipCall | null {
    return store.get(
      "PermitAndDepositDaitransferOwnershipCall",
      id
    ) as PermitAndDepositDaitransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolAwardCapturedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolAwardCapturedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolAwardCapturedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolAwardCapturedEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolAwardCapturedEvent | null {
    return store.get(
      "CompoundPrizePoolAwardCapturedEvent",
      id
    ) as CompoundPrizePoolAwardCapturedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolAwardedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolAwardedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolAwardedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolAwardedEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolAwardedEvent | null {
    return store.get(
      "CompoundPrizePoolAwardedEvent",
      id
    ) as CompoundPrizePoolAwardedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get winner(): Bytes {
    let value = this.get("winner");
    return value.toBytes();
  }

  set winner(value: Bytes) {
    this.set("winner", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolAwardedExternalERC20Event extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolAwardedExternalERC20Event entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolAwardedExternalERC20Event entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolAwardedExternalERC20Event",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePoolAwardedExternalERC20Event | null {
    return store.get(
      "CompoundPrizePoolAwardedExternalERC20Event",
      id
    ) as CompoundPrizePoolAwardedExternalERC20Event | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get winner(): Bytes {
    let value = this.get("winner");
    return value.toBytes();
  }

  set winner(value: Bytes) {
    this.set("winner", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolAwardedExternalERC721Event extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolAwardedExternalERC721Event entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolAwardedExternalERC721Event entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolAwardedExternalERC721Event",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePoolAwardedExternalERC721Event | null {
    return store.get(
      "CompoundPrizePoolAwardedExternalERC721Event",
      id
    ) as CompoundPrizePoolAwardedExternalERC721Event | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get winner(): Bytes {
    let value = this.get("winner");
    return value.toBytes();
  }

  set winner(value: Bytes) {
    this.set("winner", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get tokenIds(): Array<BigInt> {
    let value = this.get("tokenIds");
    return value.toBigIntArray();
  }

  set tokenIds(value: Array<BigInt>) {
    this.set("tokenIds", Value.fromBigIntArray(value));
  }
}

export class CompoundPrizePoolCompoundPrizePoolInitializedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolCompoundPrizePoolInitializedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolCompoundPrizePoolInitializedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolCompoundPrizePoolInitializedEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): CompoundPrizePoolCompoundPrizePoolInitializedEvent | null {
    return store.get(
      "CompoundPrizePoolCompoundPrizePoolInitializedEvent",
      id
    ) as CompoundPrizePoolCompoundPrizePoolInitializedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get cToken(): Bytes {
    let value = this.get("cToken");
    return value.toBytes();
  }

  set cToken(value: Bytes) {
    this.set("cToken", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolControlledTokenAddedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolControlledTokenAddedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolControlledTokenAddedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolControlledTokenAddedEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePoolControlledTokenAddedEvent | null {
    return store.get(
      "CompoundPrizePoolControlledTokenAddedEvent",
      id
    ) as CompoundPrizePoolControlledTokenAddedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolCreditBurnedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolCreditBurnedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolCreditBurnedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolCreditBurnedEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolCreditBurnedEvent | null {
    return store.get(
      "CompoundPrizePoolCreditBurnedEvent",
      id
    ) as CompoundPrizePoolCreditBurnedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolCreditMintedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolCreditMintedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolCreditMintedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolCreditMintedEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolCreditMintedEvent | null {
    return store.get(
      "CompoundPrizePoolCreditMintedEvent",
      id
    ) as CompoundPrizePoolCreditMintedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolCreditPlanSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolCreditPlanSetEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolCreditPlanSetEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolCreditPlanSetEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolCreditPlanSetEvent | null {
    return store.get(
      "CompoundPrizePoolCreditPlanSetEvent",
      id
    ) as CompoundPrizePoolCreditPlanSetEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get creditLimitMantissa(): BigInt {
    let value = this.get("creditLimitMantissa");
    return value.toBigInt();
  }

  set creditLimitMantissa(value: BigInt) {
    this.set("creditLimitMantissa", Value.fromBigInt(value));
  }

  get creditRateMantissa(): BigInt {
    let value = this.get("creditRateMantissa");
    return value.toBigInt();
  }

  set creditRateMantissa(value: BigInt) {
    this.set("creditRateMantissa", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolDepositedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolDepositedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolDepositedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolDepositedEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolDepositedEvent | null {
    return store.get(
      "CompoundPrizePoolDepositedEvent",
      id
    ) as CompoundPrizePoolDepositedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get referrer(): Bytes {
    let value = this.get("referrer");
    return value.toBytes();
  }

  set referrer(value: Bytes) {
    this.set("referrer", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolInitializedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolInitializedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolInitializedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolInitializedEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolInitializedEvent | null {
    return store.get(
      "CompoundPrizePoolInitializedEvent",
      id
    ) as CompoundPrizePoolInitializedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get trustedForwarder(): Bytes {
    let value = this.get("trustedForwarder");
    return value.toBytes();
  }

  set trustedForwarder(value: Bytes) {
    this.set("trustedForwarder", Value.fromBytes(value));
  }

  get reserveRegistry(): Bytes {
    let value = this.get("reserveRegistry");
    return value.toBytes();
  }

  set reserveRegistry(value: Bytes) {
    this.set("reserveRegistry", Value.fromBytes(value));
  }

  get maxExitFeeMantissa(): BigInt {
    let value = this.get("maxExitFeeMantissa");
    return value.toBigInt();
  }

  set maxExitFeeMantissa(value: BigInt) {
    this.set("maxExitFeeMantissa", Value.fromBigInt(value));
  }

  get maxTimelockDuration(): BigInt {
    let value = this.get("maxTimelockDuration");
    return value.toBigInt();
  }

  set maxTimelockDuration(value: BigInt) {
    this.set("maxTimelockDuration", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolInstantWithdrawalEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolInstantWithdrawalEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolInstantWithdrawalEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolInstantWithdrawalEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolInstantWithdrawalEvent | null {
    return store.get(
      "CompoundPrizePoolInstantWithdrawalEvent",
      id
    ) as CompoundPrizePoolInstantWithdrawalEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get redeemed(): BigInt {
    let value = this.get("redeemed");
    return value.toBigInt();
  }

  set redeemed(value: BigInt) {
    this.set("redeemed", Value.fromBigInt(value));
  }

  get exitFee(): BigInt {
    let value = this.get("exitFee");
    return value.toBigInt();
  }

  set exitFee(value: BigInt) {
    this.set("exitFee", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolLiquidityCapSetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolLiquidityCapSetEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolLiquidityCapSetEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolLiquidityCapSetEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolLiquidityCapSetEvent | null {
    return store.get(
      "CompoundPrizePoolLiquidityCapSetEvent",
      id
    ) as CompoundPrizePoolLiquidityCapSetEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get liquidityCap(): BigInt {
    let value = this.get("liquidityCap");
    return value.toBigInt();
  }

  set liquidityCap(value: BigInt) {
    this.set("liquidityCap", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolOwnershipTransferredEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolOwnershipTransferredEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolOwnershipTransferredEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolOwnershipTransferredEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePoolOwnershipTransferredEvent | null {
    return store.get(
      "CompoundPrizePoolOwnershipTransferredEvent",
      id
    ) as CompoundPrizePoolOwnershipTransferredEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolPrizeStrategySetEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolPrizeStrategySetEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolPrizeStrategySetEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolPrizeStrategySetEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolPrizeStrategySetEvent | null {
    return store.get(
      "CompoundPrizePoolPrizeStrategySetEvent",
      id
    ) as CompoundPrizePoolPrizeStrategySetEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get prizeStrategy(): Bytes {
    let value = this.get("prizeStrategy");
    return value.toBytes();
  }

  set prizeStrategy(value: Bytes) {
    this.set("prizeStrategy", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolReserveFeeCapturedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolReserveFeeCapturedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolReserveFeeCapturedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolReserveFeeCapturedEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolReserveFeeCapturedEvent | null {
    return store.get(
      "CompoundPrizePoolReserveFeeCapturedEvent",
      id
    ) as CompoundPrizePoolReserveFeeCapturedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolReserveWithdrawalEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolReserveWithdrawalEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolReserveWithdrawalEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolReserveWithdrawalEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolReserveWithdrawalEvent | null {
    return store.get(
      "CompoundPrizePoolReserveWithdrawalEvent",
      id
    ) as CompoundPrizePoolReserveWithdrawalEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolTimelockDepositedEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolTimelockDepositedEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolTimelockDepositedEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolTimelockDepositedEvent", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolTimelockDepositedEvent | null {
    return store.get(
      "CompoundPrizePoolTimelockDepositedEvent",
      id
    ) as CompoundPrizePoolTimelockDepositedEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolTimelockedWithdrawalEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolTimelockedWithdrawalEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolTimelockedWithdrawalEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolTimelockedWithdrawalEvent",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePoolTimelockedWithdrawalEvent | null {
    return store.get(
      "CompoundPrizePoolTimelockedWithdrawalEvent",
      id
    ) as CompoundPrizePoolTimelockedWithdrawalEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get unlockTimestamp(): BigInt {
    let value = this.get("unlockTimestamp");
    return value.toBigInt();
  }

  set unlockTimestamp(value: BigInt) {
    this.set("unlockTimestamp", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolTimelockedWithdrawalSweptEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolTimelockedWithdrawalSweptEvent entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolTimelockedWithdrawalSweptEvent entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolTimelockedWithdrawalSweptEvent",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): CompoundPrizePoolTimelockedWithdrawalSweptEvent | null {
    return store.get(
      "CompoundPrizePoolTimelockedWithdrawalSweptEvent",
      id
    ) as CompoundPrizePoolTimelockedWithdrawalSweptEvent | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    return value.toBytes();
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get redeemed(): BigInt {
    let value = this.get("redeemed");
    return value.toBigInt();
  }

  set redeemed(value: BigInt) {
    this.set("redeemed", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolTransferredExternalERC20Event extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolTransferredExternalERC20Event entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolTransferredExternalERC20Event entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolTransferredExternalERC20Event",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): CompoundPrizePoolTransferredExternalERC20Event | null {
    return store.get(
      "CompoundPrizePoolTransferredExternalERC20Event",
      id
    ) as CompoundPrizePoolTransferredExternalERC20Event | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePooladdControlledTokenCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePooladdControlledTokenCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePooladdControlledTokenCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePooladdControlledTokenCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePooladdControlledTokenCall | null {
    return store.get(
      "CompoundPrizePooladdControlledTokenCall",
      id
    ) as CompoundPrizePooladdControlledTokenCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolawardCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolawardCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolawardCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolawardCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolawardCall | null {
    return store.get(
      "CompoundPrizePoolawardCall",
      id
    ) as CompoundPrizePoolawardCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolawardExternalERC20Call extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolawardExternalERC20Call entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolawardExternalERC20Call entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolawardExternalERC20Call", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolawardExternalERC20Call | null {
    return store.get(
      "CompoundPrizePoolawardExternalERC20Call",
      id
    ) as CompoundPrizePoolawardExternalERC20Call | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get externalToken(): Bytes {
    let value = this.get("externalToken");
    return value.toBytes();
  }

  set externalToken(value: Bytes) {
    this.set("externalToken", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolawardExternalERC721Call extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolawardExternalERC721Call entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolawardExternalERC721Call entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolawardExternalERC721Call", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolawardExternalERC721Call | null {
    return store.get(
      "CompoundPrizePoolawardExternalERC721Call",
      id
    ) as CompoundPrizePoolawardExternalERC721Call | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get externalToken(): Bytes {
    let value = this.get("externalToken");
    return value.toBytes();
  }

  set externalToken(value: Bytes) {
    this.set("externalToken", Value.fromBytes(value));
  }

  get tokenIds(): Array<BigInt> {
    let value = this.get("tokenIds");
    return value.toBigIntArray();
  }

  set tokenIds(value: Array<BigInt>) {
    this.set("tokenIds", Value.fromBigIntArray(value));
  }
}

export class CompoundPrizePoolbalanceCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolbalanceCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolbalanceCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolbalanceCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolbalanceCall | null {
    return store.get(
      "CompoundPrizePoolbalanceCall",
      id
    ) as CompoundPrizePoolbalanceCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolbalanceOfCreditCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolbalanceOfCreditCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolbalanceOfCreditCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolbalanceOfCreditCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolbalanceOfCreditCall | null {
    return store.get(
      "CompoundPrizePoolbalanceOfCreditCall",
      id
    ) as CompoundPrizePoolbalanceOfCreditCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolbeforeTokenTransferCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolbeforeTokenTransferCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolbeforeTokenTransferCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolbeforeTokenTransferCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolbeforeTokenTransferCall | null {
    return store.get(
      "CompoundPrizePoolbeforeTokenTransferCall",
      id
    ) as CompoundPrizePoolbeforeTokenTransferCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolcalculateEarlyExitFeeCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolcalculateEarlyExitFeeCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolcalculateEarlyExitFeeCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolcalculateEarlyExitFeeCall",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePoolcalculateEarlyExitFeeCall | null {
    return store.get(
      "CompoundPrizePoolcalculateEarlyExitFeeCall",
      id
    ) as CompoundPrizePoolcalculateEarlyExitFeeCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get exitFee(): BigInt {
    let value = this.get("exitFee");
    return value.toBigInt();
  }

  set exitFee(value: BigInt) {
    this.set("exitFee", Value.fromBigInt(value));
  }

  get burnedCredit(): BigInt {
    let value = this.get("burnedCredit");
    return value.toBigInt();
  }

  set burnedCredit(value: BigInt) {
    this.set("burnedCredit", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolcalculateTimelockDurationCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolcalculateTimelockDurationCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolcalculateTimelockDurationCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolcalculateTimelockDurationCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): CompoundPrizePoolcalculateTimelockDurationCall | null {
    return store.get(
      "CompoundPrizePoolcalculateTimelockDurationCall",
      id
    ) as CompoundPrizePoolcalculateTimelockDurationCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get durationSeconds(): BigInt {
    let value = this.get("durationSeconds");
    return value.toBigInt();
  }

  set durationSeconds(value: BigInt) {
    this.set("durationSeconds", Value.fromBigInt(value));
  }

  get burnedCredit(): BigInt {
    let value = this.get("burnedCredit");
    return value.toBigInt();
  }

  set burnedCredit(value: BigInt) {
    this.set("burnedCredit", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolcaptureAwardBalanceCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolcaptureAwardBalanceCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolcaptureAwardBalanceCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolcaptureAwardBalanceCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolcaptureAwardBalanceCall | null {
    return store.get(
      "CompoundPrizePoolcaptureAwardBalanceCall",
      id
    ) as CompoundPrizePoolcaptureAwardBalanceCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class CompoundPrizePooldepositToCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePooldepositToCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePooldepositToCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePooldepositToCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePooldepositToCall | null {
    return store.get(
      "CompoundPrizePooldepositToCall",
      id
    ) as CompoundPrizePooldepositToCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }

  get referrer(): Bytes {
    let value = this.get("referrer");
    return value.toBytes();
  }

  set referrer(value: Bytes) {
    this.set("referrer", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolinitializeCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolinitializeCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolinitializeCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolinitializeCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolinitializeCall | null {
    return store.get(
      "CompoundPrizePoolinitializeCall",
      id
    ) as CompoundPrizePoolinitializeCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolinitialize1Call extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolinitialize1Call entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolinitialize1Call entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolinitialize1Call", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolinitialize1Call | null {
    return store.get(
      "CompoundPrizePoolinitialize1Call",
      id
    ) as CompoundPrizePoolinitialize1Call | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolrenounceOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolrenounceOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolrenounceOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolrenounceOwnershipCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolrenounceOwnershipCall | null {
    return store.get(
      "CompoundPrizePoolrenounceOwnershipCall",
      id
    ) as CompoundPrizePoolrenounceOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolsetCreditPlanOfCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolsetCreditPlanOfCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolsetCreditPlanOfCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolsetCreditPlanOfCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolsetCreditPlanOfCall | null {
    return store.get(
      "CompoundPrizePoolsetCreditPlanOfCall",
      id
    ) as CompoundPrizePoolsetCreditPlanOfCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolsetLiquidityCapCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolsetLiquidityCapCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolsetLiquidityCapCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolsetLiquidityCapCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolsetLiquidityCapCall | null {
    return store.get(
      "CompoundPrizePoolsetLiquidityCapCall",
      id
    ) as CompoundPrizePoolsetLiquidityCapCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolsetPrizeStrategyCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolsetPrizeStrategyCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolsetPrizeStrategyCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolsetPrizeStrategyCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolsetPrizeStrategyCall | null {
    return store.get(
      "CompoundPrizePoolsetPrizeStrategyCall",
      id
    ) as CompoundPrizePoolsetPrizeStrategyCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolsweepTimelockBalancesCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolsweepTimelockBalancesCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolsweepTimelockBalancesCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolsweepTimelockBalancesCall",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePoolsweepTimelockBalancesCall | null {
    return store.get(
      "CompoundPrizePoolsweepTimelockBalancesCall",
      id
    ) as CompoundPrizePoolsweepTimelockBalancesCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get users(): Array<Address> {
    let value = this.get("users");
    return value.toAddressArray();
  }

  set users(value: Array<Address>) {
    this.set("users", Value.fromAddressArray(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class CompoundPrizePooltimelockDepositToCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePooltimelockDepositToCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePooltimelockDepositToCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePooltimelockDepositToCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePooltimelockDepositToCall | null {
    return store.get(
      "CompoundPrizePooltimelockDepositToCall",
      id
    ) as CompoundPrizePooltimelockDepositToCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }
}

export class CompoundPrizePooltransferExternalERC20Call extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePooltransferExternalERC20Call entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePooltransferExternalERC20Call entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePooltransferExternalERC20Call",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePooltransferExternalERC20Call | null {
    return store.get(
      "CompoundPrizePooltransferExternalERC20Call",
      id
    ) as CompoundPrizePooltransferExternalERC20Call | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get externalToken(): Bytes {
    let value = this.get("externalToken");
    return value.toBytes();
  }

  set externalToken(value: Bytes) {
    this.set("externalToken", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class CompoundPrizePooltransferOwnershipCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePooltransferOwnershipCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePooltransferOwnershipCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePooltransferOwnershipCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePooltransferOwnershipCall | null {
    return store.get(
      "CompoundPrizePooltransferOwnershipCall",
      id
    ) as CompoundPrizePooltransferOwnershipCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class CompoundPrizePoolwithdrawInstantlyFromCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolwithdrawInstantlyFromCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolwithdrawInstantlyFromCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolwithdrawInstantlyFromCall",
      id.toString(),
      this
    );
  }

  static load(id: string): CompoundPrizePoolwithdrawInstantlyFromCall | null {
    return store.get(
      "CompoundPrizePoolwithdrawInstantlyFromCall",
      id
    ) as CompoundPrizePoolwithdrawInstantlyFromCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }

  get maximumExitFee(): BigInt {
    let value = this.get("maximumExitFee");
    return value.toBigInt();
  }

  set maximumExitFee(value: BigInt) {
    this.set("maximumExitFee", Value.fromBigInt(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolwithdrawReserveCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolwithdrawReserveCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolwithdrawReserveCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CompoundPrizePoolwithdrawReserveCall", id.toString(), this);
  }

  static load(id: string): CompoundPrizePoolwithdrawReserveCall | null {
    return store.get(
      "CompoundPrizePoolwithdrawReserveCall",
      id
    ) as CompoundPrizePoolwithdrawReserveCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}

export class CompoundPrizePoolwithdrawWithTimelockFromCall extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save CompoundPrizePoolwithdrawWithTimelockFromCall entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CompoundPrizePoolwithdrawWithTimelockFromCall entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set(
      "CompoundPrizePoolwithdrawWithTimelockFromCall",
      id.toString(),
      this
    );
  }

  static load(
    id: string
  ): CompoundPrizePoolwithdrawWithTimelockFromCall | null {
    return store.get(
      "CompoundPrizePoolwithdrawWithTimelockFromCall",
      id
    ) as CompoundPrizePoolwithdrawWithTimelockFromCall | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromAddress(): Bytes {
    let value = this.get("fromAddress");
    return value.toBytes();
  }

  set fromAddress(value: Bytes) {
    this.set("fromAddress", Value.fromBytes(value));
  }

  get toAddress(): Bytes | null {
    let value = this.get("toAddress");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set toAddress(value: Bytes | null) {
    if (value === null) {
      this.unset("toAddress");
    } else {
      this.set("toAddress", Value.fromBytes(value as Bytes));
    }
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get controlledToken(): Bytes {
    let value = this.get("controlledToken");
    return value.toBytes();
  }

  set controlledToken(value: Bytes) {
    this.set("controlledToken", Value.fromBytes(value));
  }

  get value0(): BigInt {
    let value = this.get("value0");
    return value.toBigInt();
  }

  set value0(value: BigInt) {
    this.set("value0", Value.fromBigInt(value));
  }
}
